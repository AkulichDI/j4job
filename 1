// <![CDATA[
/*! UTF8 */ 
/*& 3600 */

// Флажок симуляции (true = только логируем действия, без изменений)
def DRY_RUN = true

// Вставьте CSV-текст в виде многострочной строки.
// Формат: Фамилия,Имя,Отчество (остальные столбцы игнорируются, разделитель – запятая).
def csvText = """
Иванов,Иван,Иванович, ...
Петров,Пётр,Петрович, ...
Сидоров,Сидор,Сидорович, ...
"""

// Преобразуем CSV в список ФИО
def names = []
csvText.trim().readLines().each { line ->
    if (!line.trim()) return
    def cols = line.split(',') as List
    // Берём только первую колонку (Фамилия Имя Отчество) и удаляем возможные кавычки/пробелы
    def fio = cols[0].trim()
    if (fio) names << fio
}

int employeesProcessed = 0
int tasksReassigned = 0
int licensesChanged = 0
def notFoundList = []

// Предопределённый набор статус-кодов завершённых задач
def closedStatuses = ['resolved','closed','done','разрешено','закрыто'] as Set

names.each { fullName ->
    // Разбиваем ФИО на части, убирая лишние пробелы
    def parts = fullName.split(/\s+/)
    if (parts.size() < 2) {
        // Некорректное ФИО
        logger.warn("Невозможно разобрать ФИО: ${fullName}")
        notFoundList << fullName
        return
    }
    def lastName = parts[0]
    def firstName = parts.size()>1 ? parts[1] : ""
    def middleName = parts.size()>2 ? parts[2] : ""
    // Собираем паттерны для поиска с учётом регистра
    // Используем op.like для поиска по вхождению (см. пример использования op.like1)
    def searchParams = [:]
    searchParams['lastName'] = op.like(lastName)
    if (firstName)  searchParams['firstName'] = op.like(firstName)
    if (middleName) searchParams['middleName'] = op.like(middleName)
    // Параметр title учитывает полное ФИО
    searchParams['title'] = op.like(fullName)
    // Выполняем поиск сотрудников (регистр зависит от БД, см. комментарий выше)
    def emps = utils.find('employee', searchParams)
    if (!emps) {
        logger.info("Сотрудник не найден: ${fullName}")
        notFoundList << fullName
        return
    }
    // Если найдено несколько сотрудников, берём всех
    emps.each { emp ->
        employeesProcessed++
        // Получаем OU (отдел) и первую команду сотрудника (если есть)
        // Предполагаем, что emp.parent либо emp.ou даёт отдел, emp.teams – список команд
        def ouObj = null, teamObj = null
        if (emp.metaClass.hasProperty(emp, 'parent')) {
            ouObj = emp.parent    // возможно null, если нет отдела
        }
        if (emp.metaClass.hasProperty(emp, 'teams')) {
            // команды – это коллекция. Берём первую, если есть
            teamObj = (emp.teams ?: [])[0]
        }
        // Ищем все задачи (serviceCall и task) по атрибутам, связанным с этим сотрудником
        def tasks = []
        // Задачи типа serviceCall, связанные с сотрудником
        tasks += utils.find('serviceCall', ['author': emp])
        tasks += utils.find('serviceCall', ['executor': emp])        // если есть такое поле
        tasks += utils.find('serviceCall', ['responsibleEmployee': emp]) // если есть
        // Задачи типа task, связанные с сотрудником
        tasks += utils.find('task', ['author': emp])
        tasks += utils.find('task', ['executor': emp])
        tasks += utils.find('task', ['responsibleEmployee': emp])
        // Убираем дубликаты
        tasks = tasks.unique()
        // Обрабатываем найденные задачи
        int countPerEmp = 0
        for (task in tasks) {
            // Проверяем статус задачи: если он в списке завершённых, пропустить
            def state = task.state?.code?.toString()?.toLowerCase()
            if (state in closedStatuses) continue
            // Проверяем, не назначена ли задача уже на отдел/команду (т.е. нет конкретного ответственного сотрудника)
            // Предполагаем: если у задачи нет responsibleEmployee, значит она на OU/Team
            def hasEmp = task.metaClass.hasProperty(task, 'responsibleEmployee') ? task.responsibleEmployee : null
            if (!hasEmp) {
                // У задачи нет назначенного сотрудника – считаем её уже отданной отделу или команде
                continue
            }
            // Если лимит задач по сотруднику превышен – выходим
            if (countPerEmp >= 500) {
                logger.warn("Достигнут лимит 500 задач для сотрудника ${fullName}, остальные задачи пропущены")
                break
            }
            // Определяем, куда переназначить: на отдел (ou), если он есть, иначе на команду (team)
            String targetCode = null
            if (ouObj) {
                // Предполагаем, что ouObj имеет формат класса "ou" – например ou$12345
                targetCode = ouObj.toString()
                // Переназначаем через аггрегированное изменение ответственного на отдел2
                def attrs = ['aggrAttr': [targetCode]]
                if (!DRY_RUN) {
                    try {
                        api.tx.call {
                            utils.edit(task, attrs)
                        }
                    } catch (e) {
                        logger.error("Ошибка переназначения задачи ${task} на отдел ${ouObj}: " + e)
                    }
                } else {
                    logger.info("[DRY_RUN] Переназначение задачи ${task} на отдел: ${targetCode}")
                }
            } else if (teamObj) {
                // Если отдела нет, используем команду
                targetCode = teamObj.toString()
                // Переназначаем ответственным – команду3
                def attrs = ['responsible': [targetCode]]
                if (!DRY_RUN) {
                    try {
                        api.tx.call {
                            utils.edit(task, attrs)
                        }
                    } catch (e) {
                        logger.error("Ошибка переназначения задачи ${task} на команду ${teamObj}: " + e)
                    }
                } else {
                    logger.info("[DRY_RUN] Переназначение задачи ${task} на команду: ${targetCode}")
                }
            } else {
                // У сотрудника нет ни отдела, ни команды – пропускаем
                logger.warn("У сотрудника ${fullName} нет поля ou или команды для переназначения задачи ${task}")
                continue
            }
            countPerEmp++
            tasksReassigned++
        }
        // После задач – проверяем лицензию сотрудника
        // Предполагаем, что emp.license возвращает список строк-кодов лицензий
        def currentLic = emp.license ? emp.license.toString() : ""
        if (currentLic && !currentLic.contains('notLicensed')) {
            if (!DRY_RUN) {
                try {
                    api.tx.call {
                        // Устанавливаем единственную лицензию notLicensed
                        utils.edit(emp, ['license': ['notLicensed']])
                    }
                } catch (e) {
                    logger.error("Ошибка снятия лицензии у ${fullName}: " + e)
                }
            } else {
                logger.info("[DRY_RUN] Снятие лицензии у сотрудника ${fullName} (установить notLicensed)")
            }
            licensesChanged++
        }
        // Общий лимит изменений
        if (tasksReassigned >= 20000) {
            logger.warn("Достигнут общий лимит 20000 изменений, прекращаем обработку")
            break
        }
    }
    // Если общий лимит достигнут, выходим из цикла сотрудников
    if (tasksReassigned >= 20000) break
}

def summary = """Сотрудников обработано: ${employeesProcessed}
Задач переназначено: ${tasksReassigned}
Лицензий изменено: ${licensesChanged}
Не найдены сотрудники (ФИО): ${notFoundList.join(', ')}
"""
// Возвращаем итоговый лог (выводится в консоли)4.
return summary
// ]]>