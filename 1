// Сохраняем статус при смене типа запроса
// Работает в обработчике "изменение объекта (заявки)"

if (!changedAttributes?.contains('serviceType')) return           // интересует только смена типа
if (changedAttributes?.contains('state')) return                  // защита от повторного запуска

def oldCode = oldSubject?.state?.code
if (!oldCode) return

// если система уже сама оставила нужный статус — ничего не делаем
if (subject?.state?.code?.equalsIgnoreCase(oldCode)) return

// Берём процесс (жизненный цикл) НОВОЙ модели из текущего статуса (обычно "registered")
def newProcess = subject?.state?.process   // в некоторых инсталляциях: subject.state.workflow / lifeCycle

// Ищем в НОВОЙ модели статус с таким же code
def newState = newProcess
    ? dsl.select("select s from State s where s.code = :code and s.process = :proc",
                 [code: oldCode, proc: newProcess]).stream().findFirst().orElse(null)
    : dsl.select("select s from State s where s.code = :code",
                 [code: oldCode]).stream().findFirst().orElse(null)

if (!newState) return  // в новой модели нет эквивалентного статуса — оставляем "registered"

// Меняем статус без повторного срабатывания триггеров (если утилита доступна)
def doEdit = { utils.edit(subject) { it.state = newState } }
if (utils.metaClass.respondsTo(utils, 'withoutTriggers')) utils.withoutTriggers(doEdit) else doEdit()

// (необязательно) лог:
// logger.info "Сохранил статус по коду '${oldCode}' после смены типа → ${subject.state?.code}"