// НОРМАЛИЗАЦИЯ + ПОИСК ПО ФИО
def findEmployeeByFio = { String fio ->
  try {
    // 1) нормализуем пробелы и 'ё'→'е' (часто помогает)
    def norm = fio?.trim()?.replaceAll(/\s+/, ' ')?.replace('ё','е')?.replace('Ё','Е')
    if (!norm) return null

    def p = norm.tokenize(' ')
    def last  = p.size() >= 1 ? p[0] : null
    def first = p.size() >= 2 ? p[1] : null
    def middle= p.size() >= 3 ? p[2] : null

    List found = []

    // 2) Сначала пытаемся по трём полям, но по LIKE и без учёта регистра
    if (last && first && middle) {
      found = utils.find('employee',
        [lastName:  op.like(last),
         firstName: op.like(first),
         middleName: op.like(middle)],
        sp.ignoreCase())
    }

    // 3) Если не нашли — пробуем без отчества (часто оно пустое/не совпадает)
    if (!found && last && first) {
      found = utils.find('employee',
        [lastName:  op.like(last),
         firstName: op.like(first)],
        sp.ignoreCase())
    }

    // 4) Ещё fallback — искать по title (в нём как раз «Фамилия Имя Отчество»)
    //    Ищем подстроку: %Фамилия Имя Отчество%
    if (!found) {
      found = utils.find('employee',
        [title: op.like('%' + norm + '%')],
        sp.ignoreCase())
    }

    if (!found || found.isEmpty()) return null
    if (found.size() == 1) return utils.get(found[0]) // вернётся один UUID → достаём объект

    // 5) Если кандидатов несколько — пробуем точное совпадение по title (без регистра)
    def exact = found
      .collect { utils.get(it) }
      .find { (it?.title ?: '').replace('ё','е').equalsIgnoreCase(norm) }

    return exact ?: utils.get(found[0]) // иначе берём первого кандидата
  } catch (Throwable t) {
    // если важна диагностикa — можно залогировать t.message
    return null
  }
}