/* ═════════════════════════════════════════════════════════════════════════════════════
ФИНАЛЬНЫЙ КОД v7.0 - ИСПРАВЛЕННЫЙ ДЛЯ NAUMEN SD 4.17
Версия: PRODUCTION для Naumen Service Desk 4.17

ФУНКЦИОНАЛЬНОСТЬ:
- Поиск сотрудников по ФИО из CSV
- Переназначение открытых задач на подразделение сотрудника
- Закрытие задач со статусом "разрешен"
- Изменение лицензии на notLicensed
- Архивирование сотрудника

════════════════════════════════════════════════════════════════════════════════════ */

/* ═════ ВСТАВЬТЕ CSV ЗДЕСЬ ═════ */
def CSV_TEXT = $/
Иванов Иван Иванович
Петров Пётр Петрович
/$

/* ═════ КОНФИГУРАЦИЯ ═════ */
boolean DRY_RUN = true
long SLEEP_MS = 100
int MAX_EDITS_PER_EMPLOYEE = 500
int MAX_TOTAL_EDITS = 20000
int MAX_PROCESSING_TIME_MS = 1800000

char DELIM = ','
int FIO_COL = 0

List<String> CLASSES = ['serviceCall', 'task']
List<String> REL_ATTRS = ['responsible', 'executor', 'assignee', 'author']

Set<String> RESOLVE_STATUSES = ['resolved', 'разрешен', 'разрешено', 'разрешён', 'resolve'] as Set
Set<String> SKIP_STATUSES = ['closed', 'закрыто', 'завершено', 'archived', 'архив'] as Set

/* ═════ ЛОГИРОВАНИЕ ═════ */
def log = (this.metaClass.hasProperty(this, 'logger') ? logger : [
    info:  { m -> println("[INFO] ${m}") },
    warn:  { m -> println("[WARN] ${m}") },
    error: { m -> println("[ERROR] ${m}") },
    debug: { m -> println("[DEBUG] ${m}") }
])

def report = new StringBuilder()
def startTime = System.currentTimeMillis()

def say = { String level, String msg ->
    report.append(msg).append('\n')
    try {
        switch(level.toLowerCase()) {
            case 'i': case 'info': log.info(msg); break
            case 'w': case 'warn': log.warn(msg); break
            case 'e': case 'error': log.error(msg); break
            case 'd': case 'debug': log.debug(msg); break
        }
    } catch (Exception ignore) {}
}

def checkTimeout = { (System.currentTimeMillis() - startTime > MAX_PROCESSING_TIME_MS) }
def sleepIfNeeded = { if (SLEEP_MS > 0) try { Thread.sleep(SLEEP_MS) } catch (Exception ignore) {} }

def inTx = { Closure c ->
    try {
        if (this.metaClass.hasProperty(this, 'api') && api?.tx) {
            return api.tx.call { c.call() }
        }
        return c.call()
    } catch (Exception e) {
        say('e', "Ошибка транзакции: ${e.message}")
        return null
    }
}

/* ═════ ПАРСИНГ CSV ═════ */
def splitCsv = { String line ->
    def result = []
    def current = new StringBuilder()
    boolean inQuotes = false
    for (int i = 0; i < line.length(); i++) {
        char ch = line.charAt(i)
        if (ch == '"') {
            if (inQuotes && i + 1 < line.length() && line.charAt(i + 1) == '"') {
                current.append('"')
                i++
            } else {
                inQuotes = !inQuotes
            }
        } else if (ch == DELIM && !inQuotes) {
            result.add(current.toString().trim())
            current.setLength(0)
        } else {
            current.append(ch)
        }
    }
    result.add(current.toString().trim())
    return result
}

def buildFioList = { String csvText ->
    def fioList = []
    csvText.readLines().each { line ->
        def trimmed = line?.trim()
        if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) return
        try {
            def cols = splitCsv(line)
            def fioCell = cols.size() > FIO_COL ? cols[FIO_COL] : ''
            def normalized = fioCell?.replace('\u00A0', ' ')?.replaceAll(/\s+/, ' ')?.trim()
            if (!normalized) return
            def words = normalized.tokenize(' ')
            if (words.size() < 2) return
            def fio = words.take(3).join(' ')
            if (!fioList.contains(fio)) fioList.add(fio)
        } catch (Exception e) {
            say('w', "Ошибка CSV: ${line}")
        }
    }
    return fioList
}

/* ═════ ПОИСК СОТРУДНИКА ═════ */
def normalizeFio = { String s ->
    (s ?: '').replace('\u00A0', ' ').replaceAll(/\s+/, ' ')
        .replace('ё', 'е').replace('Ё', 'Е').trim()
}

def toObj = { any ->
    try {
        return (any instanceof String) ? utils.get(any) : any
    } catch (Exception e) { return any }
}

def findEmployeeByFio = { String fioInput ->
    try {
        def fio = normalizeFio(fioInput)
        if (!fio) return null

        // Попытка 1: точный поиск по title
        try {
            def found = utils.find('employee', [title: fio], sp.ignoreCase())
            if (found?.size() == 1) return toObj(found[0])
        } catch (Exception ignore) {}

        // Попытка 2: поиск по LIKE
        try {
            def found = utils.find('employee', [title: op.like("%${fio}%")], sp.ignoreCase())
            if (found?.size() == 1) return toObj(found[0])
        } catch (Exception ignore) {}

        // Попытка 3: поиск по фамилии и имени отдельно
        def parts = fio.tokenize(' ')
        if (parts.size() >= 2) {
            try {
                def found = utils.find('employee', [
                    lastName: parts[0],
                    firstName: parts[1]
                ], sp.ignoreCase())
                if (found?.size() == 1) return toObj(found[0])
            } catch (Exception ignore) {}
        }

        return null
    } catch (Exception e) {
        say('d', "Ошибка поиска: ${e.message}")
        return null
    }
}

/* ═════ ПОЛУЧЕНИЕ СТАТУСА ═════ */
def getStatusCode = { obj ->
    try {
        if (!obj) return ''
        def statusObj = obj?.state ?: obj?.status
        if (!statusObj) return ''
        def code = statusObj?.code?.toString()?.toLowerCase() ?: ''
        def title = statusObj?.title?.toString()?.toLowerCase() ?: ''
        return code ?: title
    } catch (Exception e) { return '' }
}

/* ═════ ПОЛУЧЕНИЕ ОТДЕЛА СОТРУДНИКА ═════ */
def getEmployeeDepartmentUuid = { emp ->
    try {
        if (!emp) return null
        def parent = emp.parent
        if (!parent) {
            say('d', "Ошибка: emp.parent = null")
            return null
        }
        def uuid = parent?.UUID?.toString()
        if (!uuid) return null
        
        if (!uuid.contains('$')) {
            uuid = "ou\$${uuid}"
        }
        say('d', "Отдел найден: ${uuid}")
        return uuid
    } catch (Exception e) {
        say('e', "Ошибка получения отдела: ${e.message}")
        return null
    }
}

/* ═════ ПРОВЕРКА: УЖЕ НАЗНАЧЕНО ═════ */
def alreadyAssignedTo = { obj, String targetUuid ->
    try {
        def value = obj?.responsible
        if (!value) return false
        def currentUuid = value?.UUID?.toString() ?: (value instanceof String ? value : null)
        if (!currentUuid) return false
        
        if (currentUuid == targetUuid) return true
        def extractId = { uuid -> uuid.contains('$') ? uuid.split('\$', 2)[1] : uuid }
        return extractId(currentUuid) == extractId(targetUuid)
    } catch (Exception e) { return false }
}

/* ═════ ПЕРЕНАЗНАЧЕНИЕ НА ПОДРАЗДЕЛЕНИЕ ═════ */
def tryReassignToOU = { obj, String targetOuUuid ->
    try {
        if (alreadyAssignedTo(obj, targetOuUuid)) {
            return 'already_assigned'
        }

        if (DRY_RUN) {
            say('i', "    DRY: переназначение ${obj.UUID} на ${targetOuUuid}")
            return 'assigned'
        } else {
            inTx { utils.edit(obj, [responsible: targetOuUuid]) }
            say('i', "    Переназначено на OU")
            return 'assigned'
        }
    } catch (Exception e) {
        say('d', "    Попытка переназначения не удалась: ${e.message}")
        return 'failed'
    }
}

/* ═════ ЗАКРЫТИЕ ЗАДАЧИ ═════ */
def tryCloseTask = { obj ->
    try {
        def statusCode = getStatusCode(obj)
        
        if (!RESOLVE_STATUSES.contains(statusCode)) {
            return false
        }

        if (DRY_RUN) {
            say('i', "    DRY: закрытие ${obj.UUID}")
            return true
        } else {
            try {
                inTx { utils.edit(obj, [state: 'closed']) }
                say('i', "    Закрыто")
                return true
            } catch (Exception e1) {
                try {
                    inTx { utils.edit(obj, [status: [code: 'closed']]) }
                    say('i', "    Закрыто (альтернативный способ)")
                    return true
                } catch (Exception e2) {
                    say('d', "    Не удалось закрыть: ${e2.message}")
                    return false
                }
            }
        }
    } catch (Exception e) {
        say('d', "Ошибка при закрытии: ${e.message}")
        return false
    }
}

/* ═════ ПОИСК ЗАДАЧ СОТРУДНИКА ═════ */
def findEmployeeTasks = { emp ->
    def tasks = []
    def seenUuids = new HashSet()

    try {
        CLASSES.each { cls ->
            ['responsible'].each { attr ->
                try {
                    def found = utils.find(cls, [(attr): emp])
                    found?.each { obj ->
                        if (obj?.UUID && seenUuids.add(obj.UUID)) {
                            tasks.add(obj)
                        }
                    }
                } catch (Exception e) { }
            }
        }
    } catch (Exception e) {
        say('d', "Ошибка поиска задач: ${e.message}")
    }

    return tasks
}

/* ═════ ИЗМЕНЕНИЕ ЛИЦЕНЗИИ ═════ */
def changeLicense = { emp ->
    try {
        def currentLicense = emp?.license
        boolean alreadyNotLicensed = false

        if (currentLicense instanceof String) {
            alreadyNotLicensed = currentLicense.toLowerCase().contains('notlicensed')
        } else if (currentLicense?.code) {
            alreadyNotLicensed = currentLicense.code.toString().toLowerCase().contains('notlicensed')
        } else if (currentLicense?.title) {
            alreadyNotLicensed = currentLicense.title.toString().toLowerCase().contains('notlicensed')
        }

        if (alreadyNotLicensed) {
            say('d', "    Лицензия уже notLicensed")
            return false
        }

        if (DRY_RUN) {
            say('i', "    DRY: изменение лицензии на notLicensed")
            return true
        }

        inTx { utils.edit(emp, [license: 'notLicensed']) }
        say('i', "    Лицензия изменена на notLicensed")
        return true

    } catch (Exception e) {
        say('w', "    Ошибка лицензии: ${e.message}")
        return false
    }
}

/* ═════ АРХИВИРОВАНИЕ СОТРУДНИКА ═════ */
def archiveEmployee = { emp ->
    try {
        if (!emp) return false
        say('i', "  Архивирование...")

        if (DRY_RUN) {
            say('i', "    DRY: архивирование")
            return true
        }

        // Способ 1: через removed
        try {
            inTx { utils.edit(emp, [removed: true]) }
            say('i', "    Архивировано (removed=true)")
            return true
        } catch (Exception e1) {
            say('d', "    Способ removed не сработал: ${e1.message}")
        }

        // Способ 2: через state
        try {
            inTx { utils.edit(emp, [state: 'archived']) }
            say('i', "    Архивировано (state=archived)")
            return true
        } catch (Exception e2) {
            say('d', "    Способ state не сработал: ${e2.message}")
        }

        // Способ 3: через archived флаг
        try {
            inTx { utils.edit(emp, [archived: true]) }
            say('i', "    Архивировано (archived=true)")
            return true
        } catch (Exception e3) {
            say('w', "    Архивирование не получилось: все способы исчерпаны")
            return false
        }

    } catch (Exception e) {
        say('e', "  Ошибка архивации: ${e.message}")
        return false
    }
}

/* ═════ ОСНОВНОЙ ПРОЦЕСС ═════ */
try {
    say('i', "╔════════════════════════════════════════════════════════════════╗")
    say('i', "║  ПЕРЕНАЗНАЧЕНИЕ И АРХИВИРОВАНИЕ v7.0 NAUMEN SD 4.17           ║")
    say('i', "╚════════════════════════════════════════════════════════════════╝")
    say('i', "")
    say('i', "Режим: ${DRY_RUN ? 'ТЕСТИРОВАНИЕ (DRY_RUN=true)' : 'РЕАЛЬНЫЕ ИЗМЕНЕНИЯ (DRY_RUN=false)'}")
    say('i', "")

    def fioList = buildFioList(CSV_TEXT)
    say('i', "CSV: ${fioList.size()} сотрудников")

    if (fioList.isEmpty()) {
        say('w', "CSV пуст")
        return report.toString()
    }

    int processed = 0
    int tasksReassigned = 0
    int tasksClosed = 0
    int licensesChanged = 0
    int archived = 0
    def details = []

    fioList.each { String fio ->
        processed++
        if (checkTimeout()) return

        say('i', "")
        say('i', "═══════════════════════════════════════════════════════════════")
        say('i', "[${processed}/${fioList.size()}] Поиск: ${fio}")
        say('i', "═══════════════════════════════════════════════════════════════")

        // ПОИСК СОТРУДНИКА
        def emp = findEmployeeByFio(fio)
        if (!emp) {
            say('w', "Ошибка: сотрудник НЕ найден")
            return
        }

        say('i', "Найден: ${emp.title} (${emp.UUID})")

        // ПОЛУЧЕНИЕ ОТДЕЛА
        def depUuid = getEmployeeDepartmentUuid(emp)
        if (!depUuid) {
            say('e', "Ошибка: отдел не найден (parent)")
            return
        }

        say('i', "Отдел: ${depUuid}")
        say('i', "")

        // ПОИСК И ОБРАБОТКА ЗАДАЧ
        def allTasks = findEmployeeTasks(emp)
        say('i', "Найдено задач: ${allTasks.size()}")

        int empReassigned = 0
        int empClosed = 0

        allTasks.each { obj ->
            if (tasksReassigned >= MAX_TOTAL_EDITS || empReassigned >= MAX_EDITS_PER_EMPLOYEE) return
            
            try {
                def statusCode = getStatusCode(obj)
                say('i', "  Задача: ${obj.UUID} (статус: ${statusCode})")

                // Если статус "разрешен" - закрываем
                if (RESOLVE_STATUSES.contains(statusCode)) {
                    if (tryCloseTask(obj)) {
                        empClosed++
                        tasksClosed++
                    }
                }
                // Если статус "закрыто" или другие SKIP - пропускаем
                else if (SKIP_STATUSES.contains(statusCode)) {
                    say('i', "    Пропуск (статус в списке skip)")
                }
                // Все остальные - переназначаем на OU
                else {
                    if (tryReassignToOU(obj, depUuid) == 'assigned') {
                        empReassigned++
                        tasksReassigned++
                    }
                }
                sleepIfNeeded()
            } catch (Exception e) {
                say('e', "  Ошибка обработки: ${e.message}")
            }
        }

        say('i', "")
        say('i', "Результат обработки задач:")
        say('i', "  Переназначено: ${empReassigned}")
        say('i', "  Закрыто: ${empClosed}")

        // ИЗМЕНЕНИЕ ЛИЦЕНЗИИ
        say('i', "")
        say('i', "Изменение лицензии...")
        def licenseOk = changeLicense(emp)
        if (licenseOk) licensesChanged++

        // АРХИВИРОВАНИЕ
        say('i', "")
        if (archiveEmployee(emp)) {
            archived++
            say('i', "  ОК: архивирован")
            details.add("ОК: ${emp.title} - переназначено ${empReassigned}, закрыто ${empClosed}, архив успех")
        } else {
            say('w', "  Ошибка: архивирование не получилось, но задачи обработаны")
            details.add("ОШИБКА: ${emp.title} - переназначено ${empReassigned}, закрыто ${empClosed}, архив ОШИБКА")
        }

        sleepIfNeeded()
    }

    // ИТОГИ
    say('i', "")
    say('i', "╔════════════════════════════════════════════════════════════════╗")
    say('i', "║                    ИТОГОВЫЙ ОТЧЁТ                            ║")
    say('i', "╚════════════════════════════════════════════════════════════════╝")
    say('i', "")
    say('i', "РЕЗУЛЬТАТЫ:")
    say('i', "  Обработано сотрудников: ${processed}")
    say('i', "  Задач переназначено: ${tasksReassigned}")
    say('i', "  Задач закрыто: ${tasksClosed}")
    say('i', "  Лицензий изменено: ${licensesChanged}")
    say('i', "  Сотрудников архивировано: ${archived}")
    say('i', "")
    say('i', "ДЕТАЛИ:")
    details.each { detail -> say('i', "  ${detail}") }

    if (DRY_RUN) {
        say('i', "")
        say('i', "ВНИМАНИЕ: РЕЖИМ ТЕСТИРОВАНИЯ - измените DRY_RUN=false для применения изменений")
    }

    say('i', "")
    say('i', "ЗАВЕРШЕНО")

} catch (Exception e) {
    say('e', "!!! КРИТИЧЕСКАЯ ОШИБКА !!!")
    say('e', "${e.class.name}: ${e.message}")
    try {
        e.getStackTrace().take(5).each { trace -> say('e', "  ${trace}") }
    } catch (Exception ignore) {}
}

return report.toString()